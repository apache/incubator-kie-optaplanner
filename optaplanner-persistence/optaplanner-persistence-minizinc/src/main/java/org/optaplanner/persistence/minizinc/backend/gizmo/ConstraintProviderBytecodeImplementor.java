/*
 * Copyright 2021 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.optaplanner.persistence.minizinc.backend.gizmo;

import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
import static org.objectweb.asm.Opcodes.ACC_INTERFACE;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;

import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.optaplanner.core.api.score.stream.Constraint;
import org.optaplanner.core.api.score.stream.ConstraintFactory;
import org.optaplanner.core.api.score.stream.ConstraintProvider;
import org.optaplanner.persistence.minizinc.FlatZincModel;
import org.optaplanner.persistence.minizinc.backend.FlatZincBuiltIns;
import org.optaplanner.persistence.minizinc.model.FlatZincArray;
import org.optaplanner.persistence.minizinc.model.FlatZincConstraint;
import org.optaplanner.persistence.minizinc.model.FlatZincExpr;

import io.quarkus.gizmo.ClassCreator;
import io.quarkus.gizmo.ClassOutput;
import io.quarkus.gizmo.Gizmo;
import io.quarkus.gizmo.MethodCreator;
import io.quarkus.gizmo.MethodDescriptor;
import io.quarkus.gizmo.ResultHandle;

public class ConstraintProviderBytecodeImplementor {
    /**
     * The Gizmo generated bytecode. Used by
     * gizmoClassLoader.
     */
    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();

    private static int previousId = 0;
    private static final String BASE_PACKAGE = "org.optaplanner.persistence.minizinc.compiled.model.";

    /**
     * A custom classloader that looks for the class in
     * classNameToBytecode
     */
    static final ClassLoader gizmoClassLoader = new ClassLoader() {
        // getName() is an abstract method in Java 11 but not in Java 8
        public String getName() {
            return "OptaPlanner Gizmo FlatZinc ConstraintProvider ClassLoader";
        }

        @Override
        public Class<?> findClass(String name) throws ClassNotFoundException {
            if (classNameToBytecode.containsKey(name)) {
                // Gizmo generated class
                byte[] byteCode = classNameToBytecode.get(name);
                return defineClass(name, byteCode, 0, byteCode.length);
            } else {
                // Not a Gizmo generated class; load from context class loader
                return Thread.currentThread().getContextClassLoader().loadClass(name);
            }
        }
    };

    /**
     * Creates a Marker class that extends a base interface.
     * It'll create a new one on each invocation.
     *
     * Ex: public interface Marker extends IntVariable {}
     *
     * @param baseInterface The base interface to extend
     * @return Never null, a new interface class that extends the base interface with no new methods
     */
    public static Class<?> createMarkerClass(Class<?> baseInterface) {
        String className = BASE_PACKAGE + "Marker" + previousId;
        previousId++;
        ClassWriter classWriter = new ClassWriter(Gizmo.ASM_API_VERSION);
        classWriter.visit(Opcodes.V11, ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE, className.replace('.', '/'), null,
                "java/lang/Object", new String[] { baseInterface.getName().replace('.', '/') });
        classWriter.visitEnd();

        classNameToBytecode.put(className, classWriter.toByteArray());
        try {
            return gizmoClassLoader.loadClass(className);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException("Generated class was not found", e);
        }
    }

    @SuppressWarnings("unchecked")
    public static CompiledConstraintProviderData createConstraintProviderFromFlatZincModel(FlatZincModel flatZincModel) {
        String className = BASE_PACKAGE + "FlatZincConstraintProvider" + previousId;
        previousId++;

        AtomicReference<byte[]> bytecodeReference = new AtomicReference<>();
        ClassOutput classOutput = (path, bytecode) -> {
            bytecodeReference.set(bytecode);
        };

        ClassCreator classCreator = ClassCreator.builder()
                .className(className)
                .interfaces(ConstraintProvider.class)
                .classOutput(classOutput)
                .build();

        CompiledVariablesAndConstantsData variablesAndConstantsData = defineConstraints(flatZincModel, classCreator);

        classCreator.close();
        classNameToBytecode.put(className, bytecodeReference.get());

        try {
            return new CompiledConstraintProviderData(
                    (Class<? extends ConstraintProvider>) gizmoClassLoader.loadClass(className), variablesAndConstantsData);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException("Generated class was not found", e);
        }
    }

    public static CompiledVariablesAndConstantsData defineConstraints(FlatZincModel flatZincModel, ClassCreator classCreator) {
        CompiledVariablesAndConstantsData compiledModelData = new CompiledVariablesAndConstantsData();

        MethodCreator methodCreator = classCreator.getMethodCreator(MethodDescriptor.ofMethod(ConstraintProvider.class,
                "defineConstraints", Constraint[].class, ConstraintFactory.class));
        ResultHandle constraintFactory = methodCreator.getMethodParam(0);
        ResultHandle constraintArray = methodCreator.newArray(Constraint.class, flatZincModel.getConstraintList().size());

        int constraintId = 0;
        for (FlatZincConstraint flatZincConstraint : flatZincModel.getConstraintList()) {
            ResultHandle constraint =
                    defineConstraint(flatZincConstraint, compiledModelData, constraintFactory, constraintId, methodCreator);
            methodCreator.writeArrayValue(constraintArray, constraintId, constraint);
            constraintId++;
        }
        methodCreator.returnValue(constraintArray);
        methodCreator.close();
        return compiledModelData;
    }

    private static ResultHandle defineConstraint(FlatZincConstraint flatZincConstraint,
            CompiledVariablesAndConstantsData compiledModelData, ResultHandle constraintFactory, int constraintId,
            MethodCreator methodCreator) {
        Method constraintImplMethod = findBuiltinMethod(flatZincConstraint.getPredicateName());
        // Method parameters: (parameter1, parameter2,...,parameterN, constraintId, constraintFactory)
        // parameter1,...,parameterN are in the same order as the FlatZinc predicate
        ResultHandle[] parameters = new ResultHandle[constraintImplMethod.getParameterCount()];
        for (int argumentIndex = 0; argumentIndex < constraintImplMethod.getParameterCount() - 2; argumentIndex++) {
            FlatZincExpr argument = flatZincConstraint.getPredicateArguments().get(argumentIndex);
            Type parameterType = constraintImplMethod.getGenericParameterTypes()[argumentIndex];
            if (parameterType instanceof Class) {
                if (int.class.equals(parameterType)) {
                    parameters[argumentIndex] = methodCreator.load(argument.asInt());
                } else if (int[].class.equals(parameterType)) {
                    parameters[argumentIndex] = createConstantIntArray(methodCreator, argument);
                } else {
                    throw new IllegalStateException("Unhandled case: (" + parameterType + ")");
                }
            } else if (parameterType instanceof ParameterizedType) {
                ParameterizedType parameterizedType = (ParameterizedType) parameterType;
                if (parameterizedType.getRawType().equals(Class.class)) {
                    // Variable/Problem Fact
                    Class<?> baseInterface =
                            (Class<?>) ((WildcardType) parameterizedType.getActualTypeArguments()[0]).getUpperBounds()[0];
                    Class<?> markerInterface = createMarkerClass(baseInterface);
                    addMarkerClassToVariablesAndConstants(compiledModelData, argument, markerInterface);
                    parameters[argumentIndex] = methodCreator.loadClass(markerInterface);
                } else {
                    throw new IllegalStateException(
                            "Impossible State: A builtin constraint should only have Class as ParameterizedType.");
                }
            }
        }
        parameters[constraintImplMethod.getParameterCount() - 2] = methodCreator.load("Constraint " + constraintId);
        parameters[constraintImplMethod.getParameterCount() - 1] = constraintFactory;
        return methodCreator.invokeStaticMethod(MethodDescriptor.ofMethod(constraintImplMethod), parameters);
    }

    private static void addMarkerClassToVariablesAndConstants(CompiledVariablesAndConstantsData compiledModelData,
            FlatZincExpr argument, Class<?> markerInterface) {
        if (argument instanceof FlatZincArray) {
            List<FlatZincExpr> items = ((FlatZincArray) argument).getItems();
            for (int i = 0; i < items.size(); i++) {
                FlatZincExpr expr = items.get(i);
                if (expr.isVariable()) {
                    createIfAbsent(expr.asVariable(),
                            compiledModelData.getVariableToMarkerClassListMap(),
                            ArrayList::new).add(markerInterface);
                    Map<Class<?>, List<Integer>> markerClassToListIndexes = createIfAbsent(expr.asVariable(),
                            compiledModelData.getVariableToMarkerClassToListIndexesMap(),
                            HashMap::new);
                    createIfAbsent(markerInterface, markerClassToListIndexes, ArrayList::new).add(i);
                } else {
                    createIfAbsent(expr.getValue(),
                            compiledModelData.getConstantToMarkerClassListMap(),
                            ArrayList::new).add(markerInterface);
                    Map<Class<?>, List<Integer>> markerClassToListIndexes = createIfAbsent(expr.getValue(),
                            compiledModelData.getConstantToMarkerClassToListIndexesMap(),
                            HashMap::new);
                    createIfAbsent(markerInterface, markerClassToListIndexes, ArrayList::new).add(i);
                }
            }
        } else {
            if (argument.isVariable()) {
                createIfAbsent(argument.asVariable(),
                        compiledModelData.getVariableToMarkerClassListMap(),
                        ArrayList::new).add(markerInterface);
            } else {
                createIfAbsent(argument.getValue(),
                        compiledModelData.getConstantToMarkerClassListMap(),
                        ArrayList::new).add(markerInterface);
            }
        }
    }

    private static <Key_, Value_> Value_ createIfAbsent(Key_ key, Map<Key_, Value_> map, Supplier<Value_> valueSupplier) {
        return map.computeIfAbsent(key, ignored -> valueSupplier.get());
    }

    private static ResultHandle createConstantIntArray(MethodCreator methodCreator, FlatZincExpr argument) {
        // constant int[]
        List<Integer> intArray;
        if (argument instanceof FlatZincArray) {
            intArray = ((FlatZincArray) argument).getItems().stream().map(FlatZincExpr::asInt).collect(Collectors.toList());
        } else {
            intArray = Arrays.stream(argument.asIntSet()).boxed().collect(Collectors.toList());
        }
        ResultHandle argResultHandle = methodCreator.newArray(int.class, intArray.size());
        for (int i = 0; i < intArray.size(); i++) {
            methodCreator.writeArrayValue(argResultHandle, i, methodCreator.load(intArray.get(i)));
        }
        return argResultHandle;
    }

    private static Method findBuiltinMethod(String name) {
        for (Method method : FlatZincBuiltIns.class.getMethods()) {
            if (method.getName().equals(name)) {
                return method;
            }
        }
        throw new IllegalStateException("Could not find method (" + name + ") in builtins.");
    }
}
