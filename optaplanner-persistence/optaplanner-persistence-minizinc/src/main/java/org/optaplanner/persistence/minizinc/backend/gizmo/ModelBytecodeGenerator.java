/*
 * Copyright 2021 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.optaplanner.persistence.minizinc.backend.gizmo;

import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.atomic.AtomicReference;

import org.optaplanner.core.api.domain.entity.PlanningEntity;
import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;
import org.optaplanner.core.api.domain.solution.PlanningScore;
import org.optaplanner.core.api.domain.solution.PlanningSolution;
import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;
import org.optaplanner.core.api.domain.solution.cloner.DeepPlanningClone;
import org.optaplanner.core.api.domain.valuerange.ValueRange;
import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;
import org.optaplanner.core.api.domain.variable.PlanningVariable;
import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;
import org.optaplanner.persistence.minizinc.FlatZincModel;
import org.optaplanner.persistence.minizinc.backend.IndexSet;
import org.optaplanner.persistence.minizinc.model.FlatZincArray;
import org.optaplanner.persistence.minizinc.model.FlatZincExpr;
import org.optaplanner.persistence.minizinc.model.FlatZincPlanningVariable;

import io.quarkus.gizmo.AnnotationCreator;
import io.quarkus.gizmo.BranchResult;
import io.quarkus.gizmo.BytecodeCreator;
import io.quarkus.gizmo.ClassCreator;
import io.quarkus.gizmo.ClassOutput;
import io.quarkus.gizmo.FieldCreator;
import io.quarkus.gizmo.FieldDescriptor;
import io.quarkus.gizmo.MethodCreator;
import io.quarkus.gizmo.MethodDescriptor;
import io.quarkus.gizmo.ResultHandle;

public class ModelBytecodeGenerator {
    /**
     * The Gizmo generated bytecode. Used by
     * gizmoClassLoader.
     */
    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();

    private static int previousId = 0;
    private static final String BASE_PACKAGE = "org.optaplanner.persistence.minizinc.compiled.model.";

    /**
     * A custom classloader that looks for the class in
     * classNameToBytecode
     */
    private static final ClassLoader gizmoClassLoader = new ClassLoader() {
        // getName() is an abstract method in Java 11 but not in Java 8
        public String getName() {
            return "OptaPlanner Gizmo FlatZinc Model ClassLoader";
        }

        @Override
        public Class<?> findClass(String name) throws ClassNotFoundException {
            if (classNameToBytecode.containsKey(name)) {
                // Gizmo generated class
                byte[] byteCode = classNameToBytecode.get(name);
                return defineClass(name, byteCode, 0, byteCode.length);
            } else {
                // Not a Gizmo generated class; load from context class loader
                return ConstraintProviderBytecodeImplementor.gizmoClassLoader.loadClass(name);
            }
        }
    };

    public static CompiledModelData createOptaPlannerModelFromFlatZincModel(FlatZincModel flatZincModel) {
        CompiledConstraintProviderData compiledConstraintProviderData =
                ConstraintProviderBytecodeImplementor.createConstraintProviderFromFlatZincModel(flatZincModel);
        List<FlatZincPlanningVariable> flatZincPlanningVariableList = flatZincModel.getPlanningVariableList();
        List<Class<?>> planningEntityClassList = new ArrayList<>(flatZincPlanningVariableList.size());
        Map<String, Object> planningVariableNameToInitialValue = new HashMap<>(flatZincPlanningVariableList.size());
        for (FlatZincPlanningVariable planningVariable : flatZincPlanningVariableList) {
            Object instance = createPlanningVariable(planningVariable, planningVariableNameToInitialValue,
                    compiledConstraintProviderData.getCompiledVariablesAndConstantsData()
                            .getVariableToMarkerClassListMap()
                            .getOrDefault(planningVariable.getName(), Collections.emptyList()),
                    compiledConstraintProviderData.getCompiledVariablesAndConstantsData()
                            .getVariableToMarkerClassToListIndexesMap()
                            .getOrDefault(planningVariable.getName(), Collections.emptyMap()));
            planningVariableNameToInitialValue.put(planningVariable.getName(), instance);
            if (!(instance instanceof List)) {
                planningEntityClassList.add(instance.getClass());
            }
        }

        Object planningSolution = createPlanningSolution(compiledConstraintProviderData, planningVariableNameToInitialValue);
        return new CompiledModelData(compiledConstraintProviderData.getConstraintProviderClass(),
                planningSolution.getClass(),
                planningEntityClassList,
                gizmoClassLoader,
                planningSolution);
    }

    public static Object createPlanningVariable(FlatZincPlanningVariable planningVariable,
            Map<String, Object> planningVariableNameToInitialValue,
            List<Class<?>> implementedInterfaces,
            Map<Class<?>, List<Integer>> arrayMarkerClassToIndexListMap) {
        if (planningVariable.getDefaultValue().isPresent()) {
            FlatZincExpr defaultValue = planningVariable.getDefaultValue().get();
            if (defaultValue instanceof FlatZincArray) {
                return getDefaultValueArray(planningVariableNameToInitialValue, (FlatZincArray) defaultValue);
            } else {
                return createPlanningVariableClass(planningVariable, defaultValue, implementedInterfaces,
                        arrayMarkerClassToIndexListMap);
            }
        } else {
            return createPlanningVariableClass(planningVariable, null, implementedInterfaces, arrayMarkerClassToIndexListMap);
        }
    }

    private static Object createPlanningVariableClass(FlatZincPlanningVariable planningVariable,
            Object defaultValue,
            List<Class<?>> implementedInterfaces,
            Map<Class<?>, List<Integer>> arrayMarkerClassToIndexListMap) {
        AtomicReference<byte[]> bytecodeReference = new AtomicReference<>();
        ClassOutput classOutput = (path, bytecode) -> {
            bytecodeReference.set(bytecode);
        };

        final String className = BASE_PACKAGE + "PlanningVariable" + previousId;
        ClassCreator classCreator = ClassCreator.builder()
                .className(className)
                .interfaces(implementedInterfaces.toArray(Class[]::new))
                .classOutput(classOutput)
                .build();
        previousId++;
        classCreator.addAnnotation(PlanningEntity.class);

        String valueRangeProviderName = planningVariable.getName() + "ValueRange";
        Class<?> type = getTypeOfValueRange(planningVariable.getValueRange());
        FieldCreator valueFieldCreator = classCreator.getFieldCreator("value", type);
        valueFieldCreator.setModifiers(Modifier.PUBLIC);
        AnnotationCreator annotationCreator = valueFieldCreator.addAnnotation(PlanningVariable.class);
        annotationCreator.addValue("valueRangeProviderRefs", new String[] { valueRangeProviderName });

        FieldCreator valueRangeFieldCreator =
                classCreator.getFieldCreator("valueRange", planningVariable.getValueRange().getClass());
        valueRangeFieldCreator.addAnnotation(ValueRangeProvider.class).addValue("id", valueRangeProviderName);
        valueRangeFieldCreator.setModifiers(Modifier.STATIC | Modifier.PUBLIC);

        MethodCreator getValueMethodCreator =
                classCreator.getMethodCreator(MethodDescriptor.ofMethod(className, "getValue", type));
        ResultHandle valueResultHandle = getValueMethodCreator.readInstanceField(valueFieldCreator.getFieldDescriptor(),
                getValueMethodCreator.getThis());
        getValueMethodCreator.returnValue(valueResultHandle);

        MethodCreator toStringMethodCreator =
                classCreator.getMethodCreator(MethodDescriptor.ofMethod(className, "toString", String.class));
        valueResultHandle = toStringMethodCreator.readInstanceField(valueFieldCreator.getFieldDescriptor(),
                toStringMethodCreator.getThis());
        BranchResult isNullBranchResult = toStringMethodCreator.ifNull(valueResultHandle);
        BytecodeCreator bytecodeCreator = isNullBranchResult.trueBranch();
        bytecodeCreator.returnValue(bytecodeCreator.load("null"));
        bytecodeCreator = isNullBranchResult.falseBranch();
        bytecodeCreator.returnValue(
                bytecodeCreator.invokeVirtualMethod(MethodDescriptor.ofMethod(Object.class, "toString", String.class),
                        valueResultHandle));

        Map<Class<?>, FieldDescriptor> arrayClassToFieldDescriptor =
                addGetIndexMethod(arrayMarkerClassToIndexListMap, className, classCreator);
        classCreator.close();
        classNameToBytecode.put(className, bytecodeReference.get());

        try {
            Class<?> planningVariableClass = gizmoClassLoader.loadClass(className);
            planningVariableClass.getField("valueRange").set(null, planningVariable.getValueRange());
            for (Map.Entry<Class<?>, List<Integer>> entry : arrayMarkerClassToIndexListMap.entrySet()) {
                planningVariableClass.getField(arrayClassToFieldDescriptor.get(entry.getKey()).getName()).set(null,
                        new IndexSet(entry.getValue()));
            }
            Object instance = planningVariableClass.getConstructor().newInstance();
            planningVariableClass.getField("value").set(instance, defaultValue);
            return instance;
        } catch (Exception e) {
            throw new IllegalStateException("Impossible State: Could not access (" + className + ") or a member of it.", e);
        }
    }

    private static Class<?> getTypeOfValueRange(ValueRange<?> valueRange) {
        return valueRange.createRandomIterator(new Random(0)).next().getClass();
    }

    private static List<Object> getDefaultValueArray(Map<String, Object> planningVariableNameToInitialValue,
            FlatZincArray defaultValue) {
        List<Object> javaDefaultValue = new ArrayList<>(defaultValue.getItems().size());
        for (FlatZincExpr flatZincExpr : defaultValue.getItems()) {
            if (flatZincExpr.isVariable()) {
                javaDefaultValue.add(planningVariableNameToInitialValue.get(flatZincExpr.asVariable()));
            } else {
                javaDefaultValue.add(flatZincExpr.getValue());
            }
        }
        return javaDefaultValue;
    }

    private static Object createPlanningSolution(CompiledConstraintProviderData compiledConstraintProviderData,
            Map<String, Object> planningVariableNameToInitialValue) {
        Object[] problemFacts = createProblemFacts(compiledConstraintProviderData);
        AtomicReference<byte[]> bytecodeReference = new AtomicReference<>();
        ClassOutput classOutput = (path, bytecode) -> {
            bytecodeReference.set(bytecode);
        };

        final String className = BASE_PACKAGE + "PlanningSolution" + previousId;
        ClassCreator classCreator = ClassCreator.builder()
                .className(className)
                .classOutput(classOutput)
                .build();
        previousId++;

        classCreator.addAnnotation(PlanningSolution.class);

        FieldCreator planningScoreField = classCreator.getFieldCreator("__optaplannerScore__", HardSoftScore.class);
        planningScoreField.setModifiers(Modifier.PUBLIC);
        planningScoreField.addAnnotation(PlanningScore.class);

        FieldCreator problemFactsField = classCreator.getFieldCreator("__optaplannerProblemFacts__", Object[].class);
        problemFactsField.setModifiers(Modifier.PUBLIC);
        problemFactsField.addAnnotation(ProblemFactCollectionProperty.class);

        for (Map.Entry<String, Object> planningVariable : planningVariableNameToInitialValue.entrySet()) {
            FieldCreator planningVariableField =
                    classCreator.getFieldCreator(planningVariable.getKey(), planningVariable.getValue().getClass());
            planningVariableField.setModifiers(Modifier.PUBLIC);
            if (planningVariable.getValue() instanceof List) {
                planningVariableField.addAnnotation(DeepPlanningClone.class);
            } else {
                planningVariableField.addAnnotation(PlanningEntityProperty.class);
            }
        }

        MethodCreator toStringMethodCreator =
                classCreator.getMethodCreator(MethodDescriptor.ofMethod(className, "toString", String.class));
        ResultHandle stringBuilder = toStringMethodCreator.newInstance(MethodDescriptor.ofConstructor(StringBuilder.class));
        MethodDescriptor appendMethodDescriptor =
                MethodDescriptor.ofMethod(StringBuilder.class, "append", StringBuilder.class, Object.class);

        for (String planningVariable : planningVariableNameToInitialValue.keySet()) {
            toStringMethodCreator.invokeVirtualMethod(appendMethodDescriptor, stringBuilder,
                    toStringMethodCreator.load(planningVariable));
            toStringMethodCreator.invokeVirtualMethod(appendMethodDescriptor, stringBuilder, toStringMethodCreator.load(" = "));
            toStringMethodCreator.invokeVirtualMethod(appendMethodDescriptor, stringBuilder,
                    toStringMethodCreator.readInstanceField(FieldDescriptor.of(className, planningVariable,
                            planningVariableNameToInitialValue.get(planningVariable).getClass()),
                            toStringMethodCreator.getThis()));
            toStringMethodCreator.invokeVirtualMethod(appendMethodDescriptor, stringBuilder, toStringMethodCreator.load("\n"));
        }
        toStringMethodCreator.returnValue(
                toStringMethodCreator.invokeVirtualMethod(MethodDescriptor.ofMethod(Object.class, "toString", String.class),
                        stringBuilder));

        classCreator.close();
        classNameToBytecode.put(className, bytecodeReference.get());
        try {
            Class<?> planningSolutionClass = gizmoClassLoader.loadClass(className);
            Object instance = planningSolutionClass.getConstructor().newInstance();
            planningSolutionClass.getField("__optaplannerProblemFacts__").set(instance, problemFacts);
            for (Map.Entry<String, Object> planningVariable : planningVariableNameToInitialValue.entrySet()) {
                planningSolutionClass.getField(planningVariable.getKey()).set(instance, planningVariable.getValue());
            }
            return instance;
        } catch (Exception e) {
            e.printStackTrace();
            throw new IllegalStateException("Impossible State: Could not access (" + className + ") or a member of it.", e);
        }
    }

    private static Object[] createProblemFacts(CompiledConstraintProviderData compiledModelData) {
        Object[] out =
                new Object[compiledModelData.getCompiledVariablesAndConstantsData().getConstantToMarkerClassListMap().size()];
        int index = 0;
        for (Object constant : compiledModelData.getCompiledVariablesAndConstantsData().getConstantToMarkerClassListMap()
                .keySet()) {
            List<Class<?>> markerClasses =
                    compiledModelData.getCompiledVariablesAndConstantsData().getConstantToMarkerClassListMap().get(constant);
            Map<Class<?>, List<Integer>> indexes = compiledModelData.getCompiledVariablesAndConstantsData()
                    .getConstantToMarkerClassToListIndexesMap().get(constant);
            out[index] = createProblemFact(constant, markerClasses, indexes);
            index++;
        }
        return out;
    }

    private static Object createProblemFact(Object constant, List<Class<?>> implementedInterfaces,
            Map<Class<?>, List<Integer>> arrayMarkerClassToIndexListMap) {
        AtomicReference<byte[]> bytecodeReference = new AtomicReference<>();
        ClassOutput classOutput = (path, bytecode) -> {
            bytecodeReference.set(bytecode);
        };

        final String className = BASE_PACKAGE + "ProblemFact" + previousId;
        ClassCreator classCreator = ClassCreator.builder()
                .className(className)
                .interfaces(implementedInterfaces.toArray(Class[]::new))
                .classOutput(classOutput)
                .build();
        previousId++;

        Class<?> type = constant.getClass();
        FieldCreator valueFieldCreator = classCreator.getFieldCreator("value", type);
        valueFieldCreator.setModifiers(Modifier.STATIC | Modifier.PUBLIC);

        MethodCreator getValueMethodCreator =
                classCreator.getMethodCreator(MethodDescriptor.ofMethod(className, "getValue", type));
        getValueMethodCreator.returnValue(getValueMethodCreator.readStaticField(valueFieldCreator.getFieldDescriptor()));

        Map<Class<?>, FieldDescriptor> arrayClassToFieldDescriptor =
                addGetIndexMethod(arrayMarkerClassToIndexListMap, className, classCreator);
        classCreator.close();
        classNameToBytecode.put(className, bytecodeReference.get());

        try {
            Class<?> constantClass = gizmoClassLoader.loadClass(className);
            constantClass.getField("value").set(null, constant);
            for (Map.Entry<Class<?>, List<Integer>> entry : arrayMarkerClassToIndexListMap.entrySet()) {
                constantClass.getField(arrayClassToFieldDescriptor.get(entry.getKey()).getName()).set(null,
                        new IndexSet(entry.getValue()));
            }
            return constantClass.getConstructor().newInstance();
        } catch (Exception e) {
            throw new IllegalStateException("Impossible State: Could not access (" + className + ") or a member of it.", e);
        }
    }

    private static Map<Class<?>, FieldDescriptor> addGetIndexMethod(Map<Class<?>, List<Integer>> arrayMarkerClassToIndexListMap,
            String className, ClassCreator classCreator) {
        Map<Class<?>, FieldDescriptor> arrayClassToFieldDescriptor = new HashMap<>();
        if (arrayMarkerClassToIndexListMap != null) {
            arrayMarkerClassToIndexListMap.forEach((key, value) -> {
                FieldCreator indexSetFieldCreator = classCreator.getFieldCreator(key.getSimpleName(), IndexSet.class);
                indexSetFieldCreator.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
                arrayClassToFieldDescriptor.put(key, indexSetFieldCreator.getFieldDescriptor());
            });
        }
        BytecodeCreator currentBranch =
                classCreator.getMethodCreator(MethodDescriptor.ofMethod(className, "getIndex", IndexSet.class, Class.class));
        ResultHandle parameter = currentBranch.getMethodParam(0);
        for (Map.Entry<Class<?>, FieldDescriptor> entry : arrayClassToFieldDescriptor.entrySet()) {
            ResultHandle isInstance = currentBranch.invokeVirtualMethod(
                    MethodDescriptor.ofMethod(Object.class, "equals", boolean.class, Object.class),
                    currentBranch.loadClass(entry.getKey()), parameter);
            BranchResult isInstanceBranchResult = currentBranch.ifTrue(isInstance);
            BytecodeCreator isInstanceBranch = isInstanceBranchResult.trueBranch();
            isInstanceBranch.returnValue(isInstanceBranch.readStaticField(entry.getValue()));
            currentBranch = isInstanceBranchResult.falseBranch();
        }
        currentBranch.returnValue(currentBranch.readStaticField(FieldDescriptor.of(IndexSet.class, "EMPTY", IndexSet.class)));
        return arrayClassToFieldDescriptor;
    }
}
