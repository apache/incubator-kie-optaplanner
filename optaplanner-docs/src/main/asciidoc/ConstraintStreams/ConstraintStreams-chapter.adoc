[[constraintStreams]]
= Constraint streams score calculation
:doctype: book
:imagesdir: ..
:sectnums:
:toc: left
:icons: font
:experimental:


Constraint streams are a functional programming form of incremental score calculation in plain Java that are easy to read, write, and debug. In OptaPlanner, contraint streams are implemented thorugh the `ConstraintStreams` API.This API should feel familiar if you have worked with Java 8 Streams or SQL.

[WARNING]
====
The `ConstraintStreams/ConstraintProvider` API is an ongoing project. It works but it has many API gaps. Therefore, it is not yet rich enough to handle complex constraints.
<<explainingTheScore,Constraint justifications>> may not function properly.
//COMMENT: Lukas, what specifically  might not function.  This link is to section 5.6, Explaining the score: which constraints are broken?  Or maybe we don't need to worry about this based on your comment below?
====

// TODO Remove the previous sentence when PLANNER-1709 is fixed.

To use constraint streams in your project, implement the `ConstraintProvider` interface and inlcude the following code in your solver configuration:
//COMMENET: Is adding the code how you implement `ConstraintProvider` or do I need to do both: Implement `ConstraintProvider` and add the code to my solve configuration?

[source,xml,options="nowrap"]
----
    <solver>
      <scoreDirectorFactory>
        <constraintProviderClass>com.example.MyConstraintProvider</constraintProviderClass>
      </scoreDirectorFactory>
      ...
    </solver>
----


[[constraintStreamsIntroduction]]
== `ContraintStreams` API

You can use the Jave 8 streams API to implement an <<easyJavaScoreCalculation,easy score calculator>> that uses a functional approach, as illustrated in the following example:

[source,java,options="nowrap"]
----
    private int speakerUnavailableTimeslot() {
        int softScore = 0;
        schedule.getTalkList().stream()
                .filter(Talk::hasAnyUnavailableSpeaker)
                .forEach(talk -> {
                    softScore -= talk.getDurationInMinutes();
                });
        return softScore;
    }
----

However, this approach scales poorly because it does not perform an <<incrementalScoreCalculation,incremental calculation>>.
In the previous example,when the planning variable of a single `Talk` intety changes, to recalculate the score the Java streams package must execute the entire stream from scratch.

//COMMENT: Lukas I have made the Java streams API lowercase and not code - it looks like it's a general term that includes specific packages, for exmpl java.util.stream. Let me know if I'm mistaken. Also, if I'm using 'package' incorrectly.

On the other hand, the `ConstraintStreams` API uses <<incrementalScoreCalculation,deltas>>:

////
TODO Replace the previous sentence when PLANNER-1709 is fixed.

So it doesn't do <<incrementalScoreCalculation,deltas>>.
Nor does it support <<explainingTheScore,justifications>>.

On the other hand, the `ConstraintStreams` API uses <<incrementalScoreCalculation,deltas>>
and supports <<explainingTheScore,justifications>>:
////

[source,java,options="nowrap"]
----
    private Constraint speakerUnavailableTimeslot(ConstraintFactory factory) {
        return factory.from(Talk.class)
                .filter(Talk::hasAnyUnavailableSpeaker)
                .penalize("Speaker unavailable timeslot",
                        HardSoftScore.ONE_SOFT,
                        Talk::getDurationInMinutes);
    }
----

image::ConstraintStreams/constraintStreamIntroduction.png[align="center"]
image::ConstraintStreams/constraintStreamIncrementalCalculation.png[align="center"]
image::ConstraintStreams/constraintStreamJustification.png[align="center"]


[[constraintStreamsFilter]]
== Constraint streams API filter

image::ConstraintStreams/constraintStreamFilter.png[align="center"]


[[constraintStreamsJoin]]
== Constraint streams join BLAH
//COMMENT: waht is join? For example, parameter, argument, function....
// COMMENT: Ideally we need to move descriptive text in images out of the images and into the asciidoc. In this example, I would change to this:
//The `ContraintStreams: join() BLAH is similar to an SQL inner join. If no other joiners are used,it creates a cartesian  product. The follow illustration demonstrates the `ContraintStreams: join() BLAH without joiners."
// And then maybe talk about the example, what it is doing and so forth. Is 'cartesian product' something our audience knows?

image::ConstraintStreams/constraintStreamJoinWithoutJoiners.png[align="center"]

image::ConstraintStreams/constraintStreamJoinWithJoiners.png[align="center"]


[[constraintStreamsGroupingAndCollectors]]

== Constraint Stream API grouping and collectors

Grouping collects items in a stream according to user-provided criteria, also called a group key. This is similar to what a `GROUP BY` SQL clause does. Additionally, some grouping operations also accept one or more collectors, which provide various aggregation functions.

For example, the following code snippet groups all processes by the computer they run on, sums up all of the power required by the processes on that computer using the `ConstraintCollectors.sum(...)` collector, and then penalizes every computer whose processes consume more power than is available:

[source,java,options="nowrap"]
----
    private Constraint requiredCpuPowerTotal(ConstraintFactory constraintFactory) {
        return constraintFactory.from(CloudProcess.class)
                .groupBy(CloudProcess::getComputer, sum(CloudProcess::getRequiredCpuPower))
                .filter((computer, requiredCpuPower) -> requiredCpuPower > computer.getCpuPower())
                .penalize("requiredCpuPowerTotal",
                        HardSoftScore.ONE_HARD,
                        (computer, requiredCpuPower) -> requiredCpuPower - computer.getCpuPower());
    }
----

image::ConstraintStreams/constraintStreamGroupBy.png[align="center"]

There are several collectors available out of the box. You can also provide your own collectors by implementing the
`org.optaplanner.core.api.score.stream.uni.UniConstraintCollector` interface, or its `Bi...`, `Tri...` counterparts.
//COMMENT: Can we be more specific about Bi and Tri?

[collectorsOutOfTheBox]
=== Out-of-the-box collectors

The following section describes the collector implementations provided out of the box. This section only describes the
`int`-based variants of the collectors in detail. Many of the collectors also provide variants for other applicable result data types, such as `long`, `BigDecimal` or `Duration`. You can see a complete list in the `org.optaplanner.core.api.score.stream.ConstraintCollectors` class.

[collectorsCount]
==== Collecting `count()`

The `ConstraintCollectors.count(...)` counts all elements in a group. For example, the following use of the collector gives a number of items for two separate groups: one where the talks have unavailable speakers, and one where they do not unavailable speakers.

[source,java,options="nowrap"]
----
    private Constraint speakerAvailability(ConstraintFactory factory) {
        return factory.from(Talk.class)
                .groupBy(Talk::hasAnyUnavailableSpeaker, count())
                .penalize("speakerAvailability",
                        HardSoftScore.ONE_HARD,
                        (hasUnavailableSpeaker, count) -> ...);
    }
----

The return value for this collector is a 32-bit signed integer (`int`). There is also a 64-bit variant, `countLong()`.

[collectorsCountDistinct]
==== Collecting `countDistinct()`

The `ConstraintCollectors.countDistinct(...)` counts any element in a group once, regardless of how many times it occurs. For example, the following use of the collector provides  a number of talks in each unique room.

[source,java,options="nowrap"]
----
    private Constraint roomCount(ConstraintFactory factory) {
        return factory.from(Talk.class)
                .groupBy(Talk::getRoom, countDistinct())
                .penalize("roomCount",
                        HardSoftScore.ONE_SOFT,
                        (room, count) -> ...);
    }
----

The return value for this collector is a 32-bit signed integer (`int`). There is also a 64-bit variant, `countLong()`.

[collectorsSum]
==== Collecting `sum()`

To sum the values of a particular property of all elements in the group, use the `ConstraintCollectors.sum(...)`
collector. The following code snippet first groups all processes by the computer they run on and sums up all the power
required by the processes on that computer using the `ConstraintCollectors.sum(...)` collector.

[source,java,options="nowrap"]
----
    private Constraint requiredCpuPowerTotal(ConstraintFactory constraintFactory) {
        return constraintFactory.from(CloudProcess.class)
                .groupBy(CloudProcess::getComputer, sum(CloudProcess::getRequiredCpuPower))
                .penalize("requiredCpuPowerTotal",
                        HardSoftScore.ONE_SOFT,
                        (computer, requiredCpuPower) -> requiredCpuPower);
    }
----

The return value for this collector is a 32-bit signed integer (`int`). There are also the following variants:

* 64-bit variant `sumLong()`
* `java.math.BigDecimal`-based variant `sumBigDecimal()`
* `java.math.BigInteger`-based variant `sumBigInteger()`
* `java.time.Duration`-based variant `sumDuration()`
* `java.time.Period`-based variant `sumPeriod()`


[collectorsMinMax]
==== Minimums and maximums

To extract the minimum or maximum of a group, use the `ConstraintCollectors.min(...)` and
`ConstraintCollectors.max(...)` collectors respectively.

These collectors operate on values of properties which are `Comparable` (such as `Integer`, `String` or `Duration`),
although there are also variants of these collectors which allow you to provide your own `Comparator`.

The following example finds a computer which runs the most power-demanding process:

[source,java,options="nowrap"]
----
    private Constraint computerWithBiggestProcess(ConstraintFactory constraintFactory) {
        return constraintFactory.from(CloudProcess.class)
                .groupBy(CloudProcess::getComputer, max(CloudProcess::getRequiredCpuPower))
                .penalize("computerWithBiggestProcess",
                        HardSoftScore.ONE_HARD,
                        computer -> ...);
    }
----


[[constraintStreamsImplementations]]
== Variant implementation types

Constraint streams come in two flavours, a default implementation using Drools under the hood and a pure Java-based
implementation called _Bavet_. Drools-based implementation is more feature-complete.

Bavet is an experimental implementation focusing on raw speed, which often significantly outperforms the Drools
implementation, or even Drools itself.
However, it lacks features.
To try it out, implement the `ConstraintProvider` interface and use the following in your solver config:

[source,xml,options="nowrap"]
----
    <solver>
      <scoreDirectorFactory>
        <constraintStreamImplType>BAVET</constraintStreamImplType>
        <constraintProviderClass>com.example.MyConstraintProvider</constraintProviderClass>
      </scoreDirectorFactory>
      ...
    </solver>
----
